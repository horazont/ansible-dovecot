{% macro userdb_ldap(userdb, caller) -%}
userdb {
    driver = ldap
    args = {{ userdb.file }}

{% if not (userdb.virtualise | default(False)) %}
    default_fields = {% if userdb.allow_virtual_default | default(False) %}uid=vmail gid=mail {% endif %}home=/var/mail/%u
{% else %}
    default_fields = uid=vmail gid=mail home=/var/mail/%u
{% endif %}
}
{% endmacro -%}
{% macro userdb_pam(userdb, caller) -%}
userdb {
    driver = passwd
}
{% endmacro -%}

{% macro passdb_ldap(userdb, caller) -%}
passdb {
    driver = ldap
    args = {{ userdb.file }}
}
{% endmacro -%}
{% macro passdb_pam(userdb, caller) -%}
passdb {
    driver = pam
}
{% endmacro -%}

# Enable installed protocols
!include_try /usr/share/dovecot/protocols.d/*.protocol

# Base directory where to store runtime data.
#base_dir = /var/run/dovecot/

# Name of this instance. In multi-instance setup doveadm and other commands
# can use -i <instance_name> to select which instance is used (an alternative
# to -c <config_path>). The instance name is also added to Dovecot processes
# in ps output.
#instance_name = dovecot

{% if dovecot_login_greeting -%}
# origin: dovecot_login_greeting
login_greeting = {{ dovecot_login_greeting }}
{% endif %}

dict {
  #quota = mysql:/etc/dovecot/dovecot-dict-sql.conf.ext
  #expire = sqlite:/etc/dovecot/dovecot-dict-sql.conf.ext
}

{% for userdb in dovecot_userdb %}
{% if userdb.driver == "ldap" %}{% call userdb_ldap(userdb) %}{% endcall -%}
{% elif userdb.driver == "pam" %}{% call userdb_pam(userdb) %}{% endcall -%}
{% else -%}
{% call userdb_driver_not_known_check_what_driver_you_are_using() %}{% endcall -%}
{% endif %}
{% endfor %}

{% for passdb in dovecot_passdb %}
{% if passdb.driver == "ldap" %}{% call passdb_ldap(passdb) %}{% endcall -%}
{% elif passdb.driver == "pam" %}{% call passdb_pam(passdb) %}{% endcall -%}
{% else -%}
{% call passdb_driver_not_known_check_what_driver_you_are_using() %}{% endcall -%}
{% endif %}
{% endfor %}

mail_location = {{ dovecot_mail_location }}

{% if dovecot_replication %}
mail_plugins = $mail_plugins notify replication

service aggregator {
  fifo_listener replication-notify-fifo {
    user = root
    group = mail
    mode = 0666
  }
  unix_listener replication-notify {
    user = root
    group = mail
    mode = 0666
  }
}

service replicator {
  unix_listener replicator-doveadm {
    mode = 0666
  }
  process_min_avail = 1
}

service doveadm {
  inet_listener {
    port = {{ dovecot_doveadm_port }}
    address = {{ dovecot_doveadm_listen | join(", ") }}
  }
}

plugin {
  mail_replica = tcp:{{ dovecot_replication_peer }}:{{ dovecot_doveadm_port }}
}

doveadm_password = {{ dovecot_doveadm_secret }}
{% endif %}

namespace inbox {
  inbox = yes

  mailbox Drafts {
    special_use = \Drafts
    auto = subscribe
  }
  mailbox Junk {
    special_use = \Junk
    auto = subscribe
  }
  mailbox Trash {
    special_use = \Trash
    auto = subscribe
  }
  mailbox Sent {
    special_use = \Sent
    auto = subscribe
  }
  mailbox "Sent Messages" {
    special_use = \Sent
  }
}

service imap-login {
  inet_listener imap {
    #port = 143
    address = {{ dovecot_listen | join(", ") }}
  }

  # Number of connections to handle before starting a new process. Typically
  # the only useful values are 0 (unlimited) or 1. 1 is more secure, but 0
  # is faster. <doc/wiki/LoginProcess.txt>
  #service_count = 1

  # Number of processes to always keep waiting for more connections.
  #process_min_avail = 0

  # If you set service_count=0, you probably need to grow this.
  #vsz_limit = $default_vsz_limit
}

service imap {
  # Most of the memory goes to mmap()ing files. You may need to increase this
  # limit if you have huge mailboxes.
  #vsz_limit = $default_vsz_limit

  # Max. number of IMAP processes (connections)
  #process_limit = 1024
}

{% if dovecot_pop3 %}
service pop3-login {
  inet_listener pop3 {
    address = {{ dovecot_listen | join(", ") }}
  }
  inet_listener pop3s {
    address = {{ dovecot_listen | join(", ") }}
  }
}

service pop3 {
}
{% endif %}

service auth {
  # auth_socket_path points to this userdb socket by default. It's typically
  # used by dovecot-lda, doveadm, possibly imap process, etc. Users that have
  # full permissions to this socket are able to get a list of all usernames and
  # get the results of everyone's userdb lookups.
  #
  # The default 0666 mode allows anyone to connect to the socket, but the
  # userdb lookups will succeed only if the userdb returns an "uid" field that
  # matches the caller process's UID. Also if caller's uid or gid matches the
  # socket's uid or gid the lookup succeeds. Anything else causes a failure.
  #
  # To give the caller full permissions to lookup all users, set the mode to
  # something else than 0666 and Dovecot lets the kernel enforce the
  # permissions (e.g. 0777 allows everyone full permissions).
  unix_listener auth-userdb {
    #mode = 0666
    #user =
    #group =
  }

{% if dovecot_postfix_sasl_socket %}
  # Postfix smtp-auth
  unix_listener /var/spool/postfix/private/auth {
    mode = 0666
  }
{% endif %}

  # Auth process is run as this user.
  #user = $default_internal_user
}

service auth-worker {
  # Auth worker process is run as root by default, so that it can access
  # /etc/shadow. If this isn't necessary, the user should be changed to
  # $default_internal_user.
  #user = root
}

ssl = yes
ssl_cert = </etc/dovecot/ssl.crt
ssl_key = </etc/dovecot/ssl.key
ssl_protocols = !SSLv3 !SSLv2
ssl_cipher_list = EDH+CAMELLIA:EDH+aRSA:EECDH+aRSA+AESGCM:EECDH+aRSA+SHA384:EECDH+aRSA+SHA256:EECDH:+CAMELLIA256:+AES256:+CAMELLIA128:+AES128:+SSLv3:!aNULL:!eNULL:!LOW:!3DES:!MD5:!EXP:!PSK:!DSS:!RC4:!SEED:!ECDSA:CAMELLIA256-SHA:AES256-SHA:CAMELLIA128-SHA:AES128-SHA
ssl_prefer_server_ciphers = yes

protocol lda {
  # Space separated list of plugins to load (default is global mail_plugins).
  {% if dovecot_sieve %}
  mail_plugins = $mail_plugins sieve
  {% endif %}
}

protocol imap {
  # Space separated list of plugins to load (default is global mail_plugins).
  mail_plugins = $mail_plugins{% if dovecot_antispam %} antispam{% endif %}

  # Maximum number of IMAP connections allowed for a user from each IP address.
  # NOTE: The username is compared case-sensitively.
  #mail_max_userip_connections = 10
}

{% if dovecot_sieve %}
{% if dovecot_managesieve %}
protocols = $protocols sieve

service managesieve-login {
  inet_listener sieve {
    address = {{ dovecot_listen | join(", ") }}
    port = 4190
  }

  # Number of connections to handle before starting a new process. Typically
  # the only useful values are 0 (unlimited) or 1. 1 is more secure, but 0
  # is faster. <doc/wiki/LoginProcess.txt>
  #service_count = 1

  # Number of processes to always keep waiting for more connections.
  #process_min_avail = 0

  # If you set service_count=0, you probably need to grow this.
  #vsz_limit = 64M
}

service managesieve {
  # Max. number of ManageSieve processes (connections)
  #process_limit = 1024
}

protocol sieve {
}
{% endif %}


plugin {
  sieve = {{ dovecot_sieve_file }}
  sieve_dir = {{ dovecot_sieve_dir }}
}
{% endif %}

##
## Mailbox access control lists.
##

# vfile backend reads ACLs from "dovecot-acl" file from mail directory.
# You can also optionally give a global ACL directory path where ACLs are
# applied to all users' mailboxes. The global ACL directory contains
# one file for each mailbox, eg. INBOX or sub.mailbox. cache_secs parameter
# specifies how many seconds to wait between stat()ing dovecot-acl file
# to see if it changed.
plugin {
  #acl = vfile:/etc/dovecot/global-acls:cache_secs=300
}

# To let users LIST mailboxes shared by other users, Dovecot needs a
# shared mailbox dictionary. For example:
plugin {
  #acl_shared_dict = file:/var/lib/dovecot/shared-mailboxes
}
##
## Plugin settings
##

# All wanted plugins must be listed in mail_plugins setting before any of the
# settings take effect. See <doc/wiki/Plugins.txt> for list of plugins and
# their configuration. Note that %variable expansion is done for all values.

plugin {
  #setting_name = value
}
##
## Quota configuration.
##

# Note that you also have to enable quota plugin in mail_plugins setting.
# <doc/wiki/Quota.txt>

##
## Quota limits
##

# Quota limits are set using "quota_rule" parameters. To get per-user quota
# limits, you can set/override them by returning "quota_rule" extra field
# from userdb. It's also possible to give mailbox-specific limits, for example
# to give additional 100 MB when saving to Trash:

plugin {
  #quota_rule = *:storage=1G
  #quota_rule2 = Trash:storage=+100M

  # LDA/LMTP allows saving the last mail to bring user from under quota to
  # over quota, if the quota doesn't grow too high. Default is to allow as
  # long as quota will stay under 10% above the limit. Also allowed e.g. 10M.
  #quota_grace = 10%%
}

##
## Quota warnings
##

# You can execute a given command when user exceeds a specified quota limit.
# Each quota root has separate limits. Only the command for the first
# exceeded limit is excecuted, so put the highest limit first.
# The commands are executed via script service by connecting to the named
# UNIX socket (quota-warning below).
# Note that % needs to be escaped as %%, otherwise "% " expands to empty.

plugin {
  #quota_warning = storage=95%% quota-warning 95 %u
  #quota_warning2 = storage=80%% quota-warning 80 %u
}

# Example quota-warning service. The unix listener's permissions should be
# set in a way that mail processes can connect to it. Below example assumes
# that mail processes run as vmail user. If you use mode=0666, all system users
# can generate quota warnings to anyone.
#service quota-warning {
#  executable = script /usr/local/bin/quota-warning.sh
#  user = dovecot
#  unix_listener quota-warning {
#    user = vmail
#  }
#}

##
## Quota backends
##

# Multiple backends are supported:
#   dirsize: Find and sum all the files found from mail directory.
#            Extremely SLOW with Maildir. It'll eat your CPU and disk I/O.
#   dict: Keep quota stored in dictionary (eg. SQL)
#   maildir: Maildir++ quota
#   fs: Read-only support for filesystem quota

plugin {
  #quota = dirsize:User quota
  #quota = maildir:User quota
  #quota = dict:User quota::proxy::quota
  #quota = fs:User quota
}

# Multiple quota roots are also possible, for example this gives each user
# their own 100MB quota and one shared 1GB quota within the domain:
plugin {
  #quota = dict:user::proxy::quota
  #quota2 = dict:domain:%d:proxy::quota_domain
  #quota_rule = *:storage=102400
  #quota2_rule = *:storage=1048576
}
##
## Settings for the Sieve interpreter
##

# Do not forget to enable the Sieve plugin in 15-lda.conf and 20-lmtp.conf
# by adding it to the respective mail_plugins= settings.

{% if dovecot_debug %}
mail_debug = yes
auth_debug = yes
{% endif %}

{% if dovecot_antispam %}
plugin {
   antispam_backend = mailtrain
   antispam_mail_sendmail = /usr/local/bin/sa-learn-stdin.sh
   antispam_mail_spam = spam
   antispam_mail_notspam = ham
   antispam_mail_sendmail_args = -L
   antispam_spam = Junk;INBOX.Junk
   antispam_trash = Trash;INBOX.Trash
   antispam_allow_append_to_spam = no
}
{% endif %}
